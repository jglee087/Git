## 03 깃과 브랜치

### 03-1 브랜치란?

모든 버전 관리 시스템에는 **브랜치**라는 개념이 있다. 브랜치는 원래 나뭇가지라는 뜻이 있다. 버전 관리 시스템에서는 나무가 가지에서 줄기를 뻗듯이 여러 갈래로 퍼지는 데이터 흐름을 가리키는 말로 사용한다.

#### 브랜치가 필요한 이유

예를 들면, 제품 사용 설명서를 만든다고 하자. 그리고 깃으로 사용 설명서의 버전 관리를 한다고 하자. 제품 출시 전에는 개발 순서에 따라 사용 설명서를 작성하면 된다. 하지만 제품이 출시되고 고객사마다 추가로 요구하는 내용이 다를 것이고 요구 사항을 반영하다 보면 고객사에 따라 설명서도 달라질 것이다. 그렇다면 각 고객사의 이름을 붙인 저장소를 만들어 각각의 저장소마다 버전관리를 따로 하는 방법이 있다. 하지만 이 방법은 효율적이지 않다. 먼저 고객사마다 디렉토리를 복사하면 출시 전까지 만들었던 내용은 동일하기 때문에 자료가 중복된다. 또 버전 관리 시스템의 장점 중 하나는 파일 이름을 더럽히지 않는 것인데, 이 방법은 고객사마다 디렉토리 이름을 다르게 사용해야 한다. 마지막으로 한 가지 중요한 문제가 더 있다. 예를 들면, google에서 작업을 마친 후에 그 내용이 apple에서도 필요한 내용이라고 가정해보자. 단순하게 google에 있는 최신 상태의 코드를 복사해서 apple 디렉토리에 붙여 넣은 다음 apple 디렉토리에서 새로운 버전을 커밋하면 될까? 이러면 문제가 생길 수 도 있다. 이런 문제를 해결하는 데에 있어 **브랜치(branch)**라는 도구가 있다.



#### 브랜치 기능 살펴보기

깃으로 버전 관리를 시작하면 기본적으로 **master**라는 브랜치가 만들어진다. 사용자가 커밋할 때마다 master 브랜치는 최신 커밋을 가리킨다. 즉, 브랜치는 커밋을 가리키는 포인터와 비슷하다고 생각하면 된다. 새 브랜치를 만들면 어떻게 될까? 새 브랜치를 만들면 기존에 저장한 파일을 master 브랜치에 그대로 유지하면서 기존 파일 내용을 수정하거나 새로운 기능을 구현할 파일을 만들 수 있다. 이렇게 master 브랜치에서 뻗어 나오는 새 브랜치를 마드는 것을 **'분기(branch)한다'**고 한다.

새 브랜치에서 원하는 작업을 다 끝냈다면 새 브랜치에 있던 파일을 원래 master 브랜치에 합칠 수 있다. 이렇게 분기했던 브랜치를 master 브랜치에 합치는 것을 **병합(merge)한다**고 한다.



### 03-2 브랜치 만들기

#### 실습 상황 설정하기

1. ```
   $ mkdir manual
   $ cd manual
   ```

2. ```
   $ git init
   $ ls -al
   ```

3. work.txt 파일을 만들고 content 1이라는 텍스트를 저장한다.

4. work.txt 파일을 스테이지에 올리고 커밋한다. 커밋 메시지는 간단히 'work1'이라 하고 확인하자.

   ```
   $ git add work.txt
   $ git commit -m 'work1'
   $ git log
   ```

5. work.txt 파일을 두 번 더 커밋하자. 처음에는 content 2를 추가하고 'work2'라는 메시지와 함께 커밋하고 그 다음에는 content 3를 추가하고 'work3'라는 메시지와 함께 커밋하고 기록을 본다.

   ````
   $ git commit -am 'work2'
   $ git commit -am 'work3'
   $ git log
   ````

6. 커밋 메시지가 'work1', 'work2', 'work3'인 커밋들이 보일 것이다. master 브랜치가 가장 최신 커밋인 'work3'를 가리키고 있고, HEAD가 master 브랜치를 가리키고 있다.

#### 새 브랜치 만들기

1. 깃에서 브랜치를 만들거나 확인하는 명령은 git branch이다.

   ```
   $ git branch
   ```

2. master라고 나타난다. master는 특별한 브랜치이다. 저장소를 만들 때 기본적으로 master 브랜치가 만들어진다. 지금까지 master 브랜치에서 작업하고 있었던 것이다.

3. 새로운 브랜치를 만드려면 **git branch** 명령 뒤에 브랜치 이름을 적는다.

   ```
   $ git branch apple
   ```

4. 브랜치가 만들어져도 화면에는 아무것도 나타나지 않는다. apple 브랜치가 제대로 만들어졌는지 확인하기 위해 **git branch**를 사용해보자.

5. master 브랜치 위에 apple 브랜치가 추가되었다. 그리고 master 앞에 * 표시는 아직 우리가 master 브랜치에서 작업하고 있다는 뜻이다.

6. **git log**로 확인해 보면 커밋 로그가 HEAD->master, apple로 바뀌어 있다. 이 뜻은 브랜치가 2개이고 작업 중인 브랜치는 master 브랜치라는 것이다.

7. google 브랜치와 ms 브랜치를 만들어 보고 확인해보자.

   ```
   $ git branch google
   $ git branch ms
   $ git branch
   ```

#### 

#### 브랜치 사이 이동하기 - git checkout

1. git log로 확인해 보면 master 브랜치를 비롯해 ms, google, apple 브랜치가 'work3' 상태에서 만들어져 있다. 즉 이것은 master 브랜치 뿐만 아니라 ms, google과 apple 브랜치에도 최신 커밋이 'work3'라는 뜻이다.

2. 현재 master 브랜치에 있다. 커밋을 하나 만들어서 어떻게 달라지는지 확인해 보자. work.txt 파일 안에 **master content 4**라는 내용을 추가한 후 **master work 4**라는 메시지와 함께 커밋해 보자.

   ```
   $ git commit -am "master work4"
   ```

3. master 브랜치에 새로운 커밋이 추가되었는데 로그가 어떻게 바뀌었을까? git log 명령에 --oneline 오ㅠㅂ션을 추가해서 확인해 보자. 

4. 최신 커밋인 'master work4'는 **master 브랜치**에만 적용된다.

5. 현재 브랜치에서 다른 브랜치로 이동하면 어떻게 변하는지를 살펴보자. 다른 브랜치로 이동하려면 git checkout 명령 다음에 브랜치 이름을 사용한다. 

   ```
   $ git checkout apple
   ```

6. $ 위에 나타난 파일 경로 끝에 (apple)이라고 표시될 것이다.
7. apple 브랜치에서 **git log --oneline**명령을 사용해서 현재 브랜치의 커밋 로그를 확인하고 cat work.txt를 실행하여 어떤 커밋까지 적용되었는지 확인할 수 있다.



### 03-3 브랜치 정보 확인하기

#### 새 브랜치에서 커밋하기

apple 브랜치에서 새로운 커밋을 만들어 보자.

1. apple 브랜치에는 work.txt 파일이 있다. 이 파일에 'apple content 4'라는 텍스트를 추가하고 저장하자.

2. apple 고객사만을 위한 내용이 담긴 파일도 필요할 것이다. apple.txt라는 새로운 파일도 만든다. vim에서 apple.txt 문서를 만들고 여기에도 똑같이 'apple content 4'라는 텍스트를 입력하고 저장한다.

3. 수정된 2개의 파일을 각각 스테이지에 올릴 수도 있지만 **git add 뒤에 마침표(.)**를 추가하면 현재 저장소에서 **수정된 파일을 한꺼번에 스테이지**에 올릴 수 있다.

   ```
   $ git add .
   $ git commit -m 'apple content 4'
   ```

4. git log --oneline 명령어를 사용하여 살펴보자.
5. git log 에서 --oneline --branches 옵션을 사용하면 각 브랜치의 커밋을 함께 볼 수 있다.
6.  브랜치와 커밋의 관계를 그래프 형태로 표시하려면 git log 명령에 --graph 옵션을 함께 사용한다.
7. 커밋 내역 왼쪽에 수직선(|)이 보일 것이다. 이 점선이 커밋과 커밋의 관계를 보여주는 것이다. 그래프를 살펴보면 apple 브랜치의 최신 커밋은 apple content 4인데, 점선을 따라 apple content 4 커밋의 부모를 찾아보면 work3 커밋을 만나게 된다. 즉 apple 브랜치에서는 work3 커밋 다음에 apple content 4 커밋이 만들어졌다는 것이다.
8. master 브랜치도 살펴보자. master 브랜치의 최신 커밋은 master work4이다. 그리고 수직선을 따라가 부모 커밋을 찾아보면 'work3' 커밋이다. apple 브랜치의 커밋과 master 브랜치의 커밋이 같은 부모 커밋을 가지고 있다. master 브랜치와 apple 브랜치는 'work3' 커밋까지 같고 그 이후부터 브랜치마다 다른 커밋을 만들었다는 사실을 알 수 있다.

#### 브랜치 사이의 차이점 알아보기

브랜치마다 커밋이 점점 쌓여갈수록 브랜치 사이에 어떤 차이가 있는지 일일이 확인하기 어렵다. 이럴 때는 브랜치 이름 사이에 마침표 두개(..)를 넣는 명령으로 차이점을 쉽게 구분할 수 있다. 

```
$ git log master..apple
$ git log apple..master
```



### 03-4 브랜치 병합하기

만들어진 각 브랜치에서 작업을 하다가 어느 시점에서는 브랜치 작업을 마무리하고 기존 브랜치와 합해야 한다. 이것을 **브랜치 병합(merge)**이라고 한다.

#### 서로 다른 파일 병합하기

1. manual-2라는 깃 저장소를 만들고 git init 다음에 디렉토리를 입력하면 새로운 디렉토리를 만들고 저장소를 초기화하는 과정을 한꺼번에 처리할 수 있다.

   ```
   $ cd ~
   $ git init manual-2
   $ cd manual-2
   $ ls -al
   ```

2. work.txt 파일을 만들고 '1'이라는 내용을 입력한 후 저장하고 'work1'이라는 커밋 메시지와 함께 커밋을 한다.

   ```
   $ vim work.txt
   $ git add work.txt
   $ git commit -m 'work 1'
   ```

3. 이제 'o2'라는 브랜치를 만들어보자.

   ```
   $ git branch o2
   ```

4. 현재 master 브랜치에 master.txt라는 파일을 하나 더 만들자. vim에서 'master 2'라는 내용을 입력하고 저장하고 'master work 2'라는 메시지와 함께 커밋을 하자.

   ```
   $ vim master.txt
   $ git add master.txt
   $ git commit -m 'master work 2'
   ```

5. 이제 o2 브랜치로 체크아웃한다.

   ```
   $ git checkout o2
   ```

6. o2 브랜치에서 o2.txt라는 파일을 만들고 'o2 2'라는 내용을 저장한다. o2.txt는 'o2 work 2'라는 메시지와 함께 커밋하자.

   ```
   $ vim o2.txt
   $ git add o2.txt
   $ git commit -m 'o2 work 2'
   ```

7. git log 명령을 사용해서 현재 커밋 상태를 확인하자. 커밋 'work 1'은 master 브랜치와 o2 브랜치가 똑같이 가지고 있다. 그 다음으로 master 브랜치에는 'master work 2' 커밋이 생겼고 o2 브랜치에는 'o2 work 2' 커밋이 생겼다.

8. o2 브랜치에서 작업이 다 끝났다고 가정하고, o2 브랜치의 내용을 master 브랜치로 병합해 보자. 브랜치를 병합하려면 먼저 master 브랜치로 체크아웃해야 한다.

   ```
   $ git checkout master
   ```

9. 브랜치를 병합하려면 git merge 명령 뒤에 가져올 브랜치 이름을 적는다. master 브랜치에 o2 브랜치를 가져와 병합하려면 다음과 같다.

   ```
   $ git merget o2
   ```

10. ls -al 명령을 사용해 확인해 보면 o2 브랜치에 있던 o2.txt 파일이 master 브랜치에 합쳐졌을 것이다.

11. git log --oneline -branches --graph 명령으로 브랜치와 커밋들이 어떻게 병합되었는지 알 수 있다.



#### 같은 문서의 다른 위치를 수정했을 때 병합하기











