## 02. 깃으로 버전 관리하기

### 02-1 깃 저장소 만들기

#### 깃 초기화하기 - git init

1. 깃 저장소를 만들 디렉토리를 하나 만들기 위해 터미널 창을 열고 홈 디렉토리에 hello-git이라는 디렉토리를 만들고 cd를 이용하여 hello-git 디렉토리로 이동하자.

```
$ mkdir hello-git
$ cd hello-git
```

2. 디렉토리에서 **ls -la**라는 명령어를 입력하자. 그러면 마침표가 하나(.)인 현재 디렉토리와, 마침표가 두 개(..)인 항목은 상위 디렉토리를 나타내고 그 외에는 아무 것도 없다.
3. 이 디렉토리에서 git init 명령을 입력한다. 이 명령어는 깃을 사용할 수 있도록 디렉토리를 초기화하는 것이다. **Initailized empty ...**라는 메시지가 나타난다.

```
$ git init
```

4. **ls -la**를 사용해야 .git이라는 디렉토리를 볼 수 있다. 이 폴더는 기본적으로 숨겨져 있는데, 이는 사용자가 실수로 지우지 않기 위해서이다. 이 디렉토리(.git)는 깃을 사용하면서 버전이 저장될 **저장소**이다. 



### 02-2 버전 만들기

#### 깃에서 버전이란

깃에서 버진이란 문서를 수정하고 저장할 때마다 생기는 것이라고 생각하면 된다. 문서나 프로그램을 작성하게 되면 버전관리를 하게 된다. 버전 관리를 하다보면 많은 수의 파일이 생겨서 구분하기가 쉽지 않다. 하지만 깃과 같은 버전 관리 시스템은 만든 시간과 수정 내용까지 기록할 수 있다. 깃에서 버전을 관리하면 원래 파일 이름은 그대로 유지하면서 파일에서 무엇을 변경했는지를 변경 시점마다 저장할 수 있다. 또한 각 버전마다 작업했던 내용을 확인할 수 있고 되돌아갈 수도 있다.

#### 스테이지와 커밋

- 작업트리(working tree)

  작업트리는 파일 수정, 저장 등의 작업을 하는 디렉토리로, <u>작업 디렉토리</u>라고 한다. 이전에 만들었던 hello-git 디렉토리가 <u>작업트리</u>가 된다.

- 스테이지(stage)

  스테이지 또는 스테이징 영역이라 하고 버전으로 만들 파일이 대기하는 곳이다. 예를 들어 작업 트리에서 10개의 파일을 수정했는데 4개의 파일만 버전으로 만들려면 4개의 파일만 스테이지로 넘겨주면 된다.

- 저장소(repository)

  저장소는 스테이지에서 대기하고 있던 파일들을 버전으로 만들어 저장하는 곳이다. 스테이지와 저장소는 눈에 보이지 않는다. 깃을 초기화했을 때 만들어지는 .git 디렉토리 안에 숨은 파일 형태로 존재하는 영역이다.

  hello.txt 파일 문서를 수정하고 저장하면 그 파일은 작업 트리에 있게 된다. 그리고 수정한 hello.txt 파일을 버전으로 만들고 싶을 때 스테이지에 넣는다. 다른 파일도 수정한 뒤 버전으로 만들겠다면 스테이지에 넣어둔다.

  파일 수정을 끝내고 스테이지에 다 넣었다면 버전을 만들기 위해 깃에게 **커밋(commit)** 명령을 내린다. 커밋 명령을 내리면 새로운 버전이 생성되면서 스테이지에 대기하던 파일이 모두 저장소에 저장된다.

정리하면, 먼저 작업 트리에서 문서를 수정한다. 수정한 파일 중 버전으로 만들고 싶은 것을 스테이징 영역에 저장한다. 그리고 스테이지에 있던 파일을 저장소로 커밋하는 것이 깃이 버전을 만드는 순서이다.



#### 작업 트리에서 vim으로 문서 수정하기

1. 터미널 창을 열고 hello-git 디렉토리로 이동한다. hello-git에서 초기화했기 때문에 버전 관리를 할 수 있다. 먼저 깃 상태를 확인하기 위해 **git status**를 입력한다.

   ```
   $ git status
   ```

2. 그러면 3개의 상태 메시지가 나타난다.

   1) On branch master > 현재 master 브랜치에 있다는 것을 의미

   2) No commits yet > 아직 커밋할 파일이 없음을 의미

   3) nothing to commit  > 현재 커밋할 파일이 없음을 의미

3. hello-git 디렉토리에 새로운 테스트 파일을 만들어 본다.

   ```
   $ vim hello.txt
   ```

4.  vim 화면이 나타나면 파일에 1을 입력하고 저장하고 종료한다.

5. 터미널로 돌아와서 **ls -la** 를 입력하면 hello.txt라는 파일이 생성되었다.

6. **git status**명령어를 입력하면, untracked files가 있다고 알려준다. 깃에서는 <u>한번도 버전 관리하지 않은 파일</u>을 **untracked files**라고 한다.



#### 수정한 파일을 스테이징하기 - git add

작업 트리에서 파일을 만들거나 수정했다면 스테이지에 수정한 파일을 추가한다. 깃에게 버전 만들 준비를 하라고 알려주는 것을 **스테이징**이라고 한다.

1. 깃에서 <u>스테이징</u>할 때 사용하는 명령은 git add이다. 터미널에 git add hello.txt를 입력해도 아무 내용이 나타지 않지만 실행된 된 것이다.
2. **git status**를 입력하면 untracked files:이라는 문구가 **changes to be committed:**로 바뀌었다. 그리고 hello.txt 앞에 **new files:**이라는 수식어가 나타난다. hello.txt를 커밋하려고 하는 것이다.

수정한 파일 hello.txt'가 스테이지에 추가되었다. 



#### 스테이지에 올라온 파일 커밋하기 - git commit

파일이 스테이지에 있다면 이제 버전을 만들 수 있다. 깃에서는 버전을 만드는 것을 간단히 커밋이라고 한다. 커밋할 때는 그 버전에 어떤 변경 사항이 있었는지 확인하기 위해 메시지를 함께 기록해야 한다.

1. 깃에서 파일을 커밋하는 명령은 **git commit**이다. 한 칸 띄운 후에 -m 옵션을 붙이면 커밋과 함께 저장할 메시지를 적을 수 있다. 이 메시지를 커밋 메시지라 한다.

   ```
   $ git commit -m 'message1'
   ```

2. 커밋 후에 결과 메시지를 보면 파일 1개가 변경되었고, 파일에 1개의 내용이 추가되었다고 나타난다.

   > 1 file changed, 1 insertion(+) 이 결과 메시지이다.

   

3. 현재의 깃 상태를 확인해보자.

   ```
   $ git status
   ```

4. 결과 메시지를 보면 **버전으로 만들 파일이 없고(nothing to commit)** **작업 트리도 수정사항 없이 깨끗하다(working tree clean)**고 나타난다.

   > on branch master
   >
   > nothing to commit, working tree clean

5.  버전이 제대로 만들어졌는지 확인하려면 **git log**명령을 사용한다.

   ```
   $ git log
   ```

6. 방금 커밋한 버전에 대한 설명이 나타난다. 커밋을 만든 사람, 만든 시간과 커밋 메시지가 함께 나타난다. 수정한 파일을 커밋하면 이렇게 수정과 관련된 여러 정보를 함께 저장할 수 있고 필요할 때 확인할 수 있다.



#### 스테이징과 커밋 한꺼번에 하기 - git commit -am

commit 명령에 -am 옵션을 사용하면 스테이지에 올리고 커밋하는 과정읗 한꺼번에 처리한다.

1. vim에서 hello.txt파일을 열고 아랫줄에 텍스트 2를 넣고 저장한다.

2. 한 번 커밋한 파일이라면 git commit 명령에 -am 옵션을 붙여서 스테이징과 커밋을 한꺼번에 처리할 수 있다.

   ```
   $ git commit -am "message2"
   ```

3. 방금 커밋한 버전에 어떤 정보가 들어있는지 확인해보자.

   ```
   $ git log
   ```

4. hello.txt를 저장한 두 번째 버전의 정보가 message2라는 메시지와 함께 나타난다.



### 02-3 커밋 내용 확인하기

버전을 관리하기 위해서는 어떤 버전을 만들었는지 알 수 있어야 하고 각 버전마다 어떤 차이가 있는지도 파악할 수 있어야 한다.

#### 커밋 기록 자세히 살펴보기 - git log

git log 명령을 입력하면 지금까지 만든 버전이 화면에 나타나고, 각 버전마다 설명도 함께 나타난다.

Commit 이라는 항목 옆에 영문과 숫자로 된 문자열이 나타나는데 이것을 커밋 해시 또는 깃 해시라고 한다. 커밋을 구별하는 아이디라고 생각하면 된다. 커밋 해시 옆에 있는 (HEAD->master)는 이 버전이 가장 최신이라는 표시이다. 그리고 Author 항목과 Date 항목이 있다. 그 아래에는 작성자가 기록한 커밋 메시지가 나오는데 이러한 정보들을 **커밋 로그**라고 한다.

#### 변경 사항 확인하기 - git diff

git diff 명령을 사용하면 작업 트리에 있는 파일과 스테이지에 파일을 비교하거나, 스테이지에 있는 파일과 저장소에 있는 최신 커밋을 비교해서 수정한 파일을 커밋하기 전에 최종적으로 검토할 수 있다.

1. 앞의 내용을 계속 따라왔다면 hello.txt 파일에는 숫자 1부터 2까지 입력되어 있고, 저장소에는 2개의 버전이 저장되어 있을 것이다.

2. hello.txt 파일에 2를 two로 변경하고 저장한다.

3. git status 명령을 사용해 깃의 상태를 확인하면 hello.txt 파일이 수정되었고, 아직 스테이징 상태가 아니라고 나온다.

4. 수정한 파일이 저장소에 있는 최신 버전의 hello.txt와 어떻게 다른지 확인 해보기 위해 **git diff** 명령을 사용한다.

   ```
   $ git diff
   ```

5. 결과 창에 **-2**와 **+two**라는 기록을 볼 수 있다. 이는 2가 삭제되고 two라는 텍스트가 추가되었다는 뜻이다.

작업 트리에서 수정한 파일과 최신 버전을 비교한 다음, 수정한 내용을 버전으로 만드려면 스테이지에 올린 후 커밋하고 수정한 내용을 버리려면 **git checkout** 명령을 사용해 수정 내용을 취소한다.



### 02-4 버전 만드는 단계마다 파일 상태 알아보기

#### tracked파일과 untracked파일

git status 명령을 사용하면 화면에 파일 상태와 관련된 메시지가 나타난다. 작업 트리에 있는 파일은 크게 tracked 상태와 untracked 상태로 나뉜다. 

1. vim에서 hello.txt 파일을 열고 숫자 3을 추가한 후 저장한다.

2. hello2.txt라는 새로운 파일을 만들고 안에 알파벳 a, b, c, d를 한줄씩 입력하고 저장한다.

3. **git status**로 상태를 확인하면, hello.txt과 hello2.txt 파일 모두 작업 트리에 있다.

4. hello.txt파일은 **Changed not stated for commit:**이라고 되어 있다. 변경된 파일이 아직 스테이지에 올라가지 않았다는 뜻이다. 그리고 파일 이름 앞에 **modified:**라고 되어 있어 hello.txt가 수정되었다는 것이다. 깃은 한 번이라도 커밋을 한 파일의 수정 여부를 계속 추적하고 추적하고 있다는 뜻에서 tracked 파일이라고 한다. 반면에 hello2.txt 파일 앞에는 아무 것도 없고 **untracked files:**이라고 되어있다. 이 파일은 한 번도 깃에서 버전 관리를 하지 않았기 때문에 수정 내역을 추적하지 않는다. 그래서 **untracked** 파일이라고 표시한다.

5. 수정했던 두 파일을 모두 git add 명령을 사용해서 스테이지에 올릴 수 있다.

   ```
   $ git add hello.txt
   $ git add hello2.txt
   ```

6. **git status**를 사용해 상태를 확인해 보자.  마지막 버전 이후에 수정된 파일은 **modified:**로 표시되고, 한 번도 관리하지 않았던 파일은 **new file:**로 표시된다. tracked 파일이나 untracked 파일 모두 스테이지에 올라온 것을 확인할 수 있다.

7. 두 개의 파일을 add를 했기 때문에 커밋을 하면 두 파일이 모두 커밋이 된다. 

   ```
   $ git commit -m 'message3'
   $ git log
   ```

8. 각 커밋에 어떤 파일들이 관련된 것인지 알 수 없다. 커밋에 관련된 파일까지 함께 살펴보려면 **git log --stat**을 사용하면 가장 최근의 커밋부터 순서대로 커밋 메시지와 관련 파일이 나열된다.

   

#### unmodified, modified, staged 상태

한 번이라도 버전을 만들었던 파일은 tracked 상태가 된다. tracked 상태인 파일은 깃 명령으로 파일 상태를 확인하면 현재 작업 트리에 있는지, 스테이지에 있는지 등 구체적인 상태를 알려준다. 

1. **ls** 명령을 사용해 hello-git 디렉토리를 살펴보면 앞에서 버전을 저장한 hello.txt와 hello2.txt 파일이 있다. 

2. **git status** 명령을 사용해 깃의 상태와 파일의 상태를 살펴보자.

   ```
   $ git status
   ```

3. 작업 트리에 아무 변경 사항이 없기 때문에 **working tree clean**이라고 나타나고 현재 작업 트리에 있는 모든 파일의 상태는 unmodified이다.

4. hello2.txt에 a만 남기고 다 지운다.
5. **git status** 명령을 실행하면 파일이 수정되었고 아직 스테이지에 올라가지 않았다고 한다. **Changes not stage for commit:**이라는 메시지가 나타나면 파일이 수정만 된 modified 상태이다.

6. **git add** 명령을 사용해 스테이지에 올리고 git status 명령을 실행하면 커밋할 변경사항이 있다고 한다. 이렇게 **Changes to be committed:**라는 메시지가 나타나면 커밋 직전 단계인 **staged** 상태이다.
7. 스테이지에 있는 파일을 **git commit -m 'delete b,c,d'**를 싱행하고 **git status**를 실행하면 hello2.txt 파일의 상태는 수정이 없던 unmodified로 돌아간다.



* **방금 커밋한 메시지 수정하기**

  문서의 수정 내용을 기록해둔 커밋 메시지를 잘못 입력했다면 커밋을 만든 즉시 메시지를 수정할 수 있는데, 그 명령어는 **git commit --amend**이다.

  ```
  $ git commit --amend
  ```



### 02-5 작업 되돌리기

#### 작업 트리에서 수정한 파일 되돌리기 - git checkout

파일을 수정한 뒤 소스가 정상적으로 동작하지 않는 등의 이유로 수정한 내용을 취소하고 가장 최신 버전 상태로 되돌려야 할 때가 있다. 럴 때 checkout 명령을 사용하면 작업 트리에서 수정한 내용을 쉽게 취소할 수 있다(단, checkout으로 되돌린 내용은 다시 복구할 수 없다).

1. hello.txt 파일을 열어 3을 three를 수정한다.

2. **git status** 를 하면 파일이 수정되었지만 스테이지에 올라가 있지 않다. 그리고 두 번째 괄호 안의 메시지를 보면 작업트리의 변경사항을 취소하려면 **checkout**을 사용하라고 되어 있다.

3. **git checkout** 명령 다음데 붙임표 2개(--)를 붙이고 한 칸 띈 다음 파일 이름을 쓰면 된다.

   ```
   $ git checkout -- hello.txt
   ```

4. 정상적으로 처리되면 화면에 아무것도 나타나지 않는다. 파일을 확인하려면 cat hello.txt를 수행해보면 원래대로 돌아온 것을 확인할 수 있다.



#### 스테이징 되돌리기 - git reset HEAD [파일 이름]

1. hello2.txt의 기존 내용을 삭제하고 대문자 'A, B, C, D'를 입력한 후 저장한다.

2. **git add** 명령으로 hello2.txt 파일을 스테이지에 올린 후 git status 명령으로 파일의 상태를 살펴보자.

   ```
   $ git add hello2.txt
   $ git status
   ```

3. 상태 메시지 중 괄호 안의 내용을 읽어 보면, 스테이지에서 내리려면(to unstage) git reset HEAD 명령을 사용하라고 되어 있다.

   ```
   $ git reset HEAD hello2.txt
   ```

4. 수정된 hello2.txt가 스테이지에서 내려졌다는(unstaged) 메시지가 나타나고 **git status**로 상태를 확인해 본다.



#### 최선 커밋 되돌리기 - git reset HEAD^

수정된 파일을 스테이징하고 커밋까지 했을 때, 가장 마지막에 한 커밋을 취소하는 방법이 있다.

1. hello2.txt 문서에 대문자 E를 추가한다.

2. **git commit**명령을 사용해 스테이징과 커밋을 함께 실행하고 메시지는 'message4'로 한다. 그리고 git log 를 사용해 상태를 확인한다.

   ```
   $ git commit -am 'message4'
   $ git log
   ```

3. 최신 커밋으로 되돌리려면 git reset HEAD^를 붙인다. **HEAD^**는 현재 HEAD가 가리키는 브랜치의 최신 커밋을 가리킨다. git log 명령을 실행했을 때 가장 최신 커밋에 표시가 있던 것을 기억한다. 이렇게 되돌리면 커밋도 취소되고 스테이지에서도 내려진다.

   ```
   $ git reset HEAD^
   ```

* 최근 3개의 커밋을 취소하려면 다음과 같다.

  ```
  $ git reset HEAD~3
  ```

  

* **git reset 명령의 옵션 살펴보기**

| 명령          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| --soft HEAD^  | 최근 커밋을 하기 전 상태로 작업 트리를 되돌린다.             |
| --mixed HEAD^ | 최근 커밋과 스테이징을 하기 전 상태로 작업 트리를 되돌린다. 옵션 없이 git reset 명령을 사용할 경우 이 옵션을 기본으로 작동한다. |
| --hard HEAD^  | 최근 커밋과 스테이징, 파일 수정을 하기 전 상태로 작업 트리를 되돌린다. 이 옵션으로 되돌린 내용은 복구할 수 없다. |



#### 특정 커밋으로 되돌리기 - git reset [커밋 해시]

1. rev.txt파일을 만들고 a를 입력한 후 저장하자.

2. rev.txt를 스테이지에 올린 후 R1 메시지와 함께 커밋한다.

   ```
   $ git add rev.txt
   $ git commit -m 'R1'
   ```

3. rev.txt에 텍스트 b를 추가하고 'R2' 메시지와 함께 커밋한다.

   ```
   $ git commit -am 'R2'
   ```

4. 같은 방법으로 rev.txt에 c를 추가한 후 'R3' 메시지와 함께 커밋하고, d를 추가한 후 'R4'메시지와 함께 커밋한다.

5. **git log** 명령을 사용해 커밋을 확인하면 4개의 커밋이 있고 각 커밋마다 커밋 해시가 함께 있다. 

6. **reset**에서 커밋 해시를 사용해 되돌릴 때 주의할 점이 있다. 예를 들어 reset A를 입력한다면 이 명령은 A 커밋을 리셋하는 것이 아니라 최근 커밋을 A로 리셋한다. 즉 A 커밋 이후에 만들었던 커밋을 삭제하고 A 커밋으로 이동하겠다는 의미이다.

7. git reset 명령 다음에 --hard 옵션까지 입력한 후 복사한 커밋 해시를 붙여넣는다.

   ```
   $ git reset --hard [복사한 커밋 해시]
   ```

8. cat rev.txt를 실행하면 R2 메시지가 있는 두 번째 까지만 기록이 되고 나머지는 사라진다.



#### 커밋 삭제하지 않고 되돌리기 - git revert

나중에 사용할 것을 대비해서 커밋을 되돌리더라도 취소한 커밋을 남겨두어야 할 때가 있다. 이 때는 git reset이 아닌 git revert라는 명령을 사용해야 한다.

1. rev.txt 파일에는 영문자 a와 b가 남아 있다. 커밋은 R2까지 되어있다. 이 파일에 e를 추가한다.

2. 수정한 rev.txt를 'R5'라는 메시지와 함께 커밋하고 git log를 입력해 버전을 확인해보자.

3. 가장 최근에 커밋한 R5 버전을 취소하고, R5 직전 커밋 R2로 되돌아가려고 한다.

   ```
   $ git revert 복사한 R5 커밋 해시
   ```

4. **revert**명령을 실행할 때는 깃을 설치할 때 지정했던 기본 편집기가 자동으로 나타나면서 커밋 메시지를 입력할 수 있다. 커밋 메시지 맨 위에는 어떤 버전을 revert 했는지 나타나 있다. 문서 맨 위에 revert하면서 추가로 남겨둘 내용이 있다면 입력하고 저장한다.

5. **git log**로 확인하면 revert 되었다는 간단한 메시지가 나타난다.

6. 로그에 R5를 revert한 새로운 커밋이 생겼다. 기존의 R5역시 사라지지 않았다. R5 버전을 지우는 대신 R5에서 변경했던 이력을 취소한 새 커밋을 만든 것이다.
7. cat rev.txt를 실행하면 rev.txt파일에 마지막으로 저장되었던 e라는 문자는 사라져 있다.

8. revert 명령을 사용하면 버전에 있던 이력을 취소할 수 있다.