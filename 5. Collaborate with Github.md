## 05. 깃허브로 협업하기

### 05-1 여러 컴퓨터에서 원격 저장소 함께 사용하기

git_home과 git_office라는 2개의 디렉토리를 만들어 깃허브 협업을 연습해 보자. 1인 프로젝트를 한다면 git_home과 git_office를 개인 컴퓨터의 저장소와 회사 컴퓨터의 저장소라고 상상해도 된다. 하나는 PC, 하나는 노트북의 저장소라고 상상해도 된다. 모두 하나의 깃허브 계정으로 둘 이상의 컴퓨터에서 원격 저장소를 공유해 버전을 관리하는 방법이다.



#### 원격 저장소 복제하기 - git clone

1. 4장에서 만든 test-1이라는 원격 저장소를 계속 사용하자. 깃허브에 있는 test-1 저장소를 git_home이라는 저장소로 복제하겠다. [Clone or download]를 누른 후 주소를 복사하자.

2. 터미널 창에서 git_home 디렉토리와 git_office 디렉토리를 만들 위치로 이동한다. 여기에서 홈 디렉토리에 만들자. git clone 다음에 복사한 소스를 붙여 넣고 복제할 디렉토리 이름을 입력하면 된다. 이때 git_home이라는 디렉토리가 없다면 자동으로 디렉토리가 만들어진다. 

   ```
   $ git clone 주소 git_home
   ```

3. 원격 저장소의 내용을 git_office 디렉토리에도 복제하겠다.

   ```
   $ git clone 주소 git_office
   ```

4. ls -al 명령을 사용해 디렉토리를 확인한다.

5. git_home 디렉토리와 git_office 디렉토리에 같은 내용이 저장되어 있는지 확인해 보자. 먼저 git_home 디렉토리로 이동한 후 git log 명령을 입력해 보자.

   ```
   $ cd git_home
   $ git log
   ```

6. git_office 디렉토리로 이동한 후 git log 명령을 실행하자. git_home 디렉토리와 똑같은 커밋을 볼 수 있다.

7. 이렇게 원격 저장소를 복제하면 자동으로 지역 저장소와 원격 저장소가 연결된다. git remote -v 명령을 사용하면 연결이 되어 있는지 확인할 수 있다.

   ```
   $ git remote -v
   ```



#### 개인 컴퓨터에서 작업하고 올리기

1. git_home 디렉토리에서 텍스트 문서를 열고 간단한 내용을 추가해 보자. f1.txt 문서에 c라는 문자를 추가하자.

   ```
   $ cd ~
   $ cd git_home
   $ vim f1.txt
   ```

2. f1.txt 파일을 스테이징하고 커밋하자. git commit 명령에서 -am 옵션을 사용하면 스테이징과 커밋을 한꺼번에 할 수 있다. 커밋 메시지는 'add c'라고 지정했다. 그리고 git push 명령을 사용해 커밋을 원격 저장소에 올린다.

   ```
   $ git commit -am 'add c'
   $ git push
   ```

3. 깃허브 홈페이지에 [commits]을 눌러 확인하자

4. 마지막으로 커밋한 'add c'라는 커밋이 올라와 있다. 이렇게 원격 저장소의 내용을 복제한 지역 저장소에서 내용을 수정하고 커밋한 후 다시 원격 저장소에 올리자.



#### 회사 컴퓨터에서 내려받아 작업하기

개인 컴퓨터에서 커밋을 푸시했기 때문에 회사 컴퓨터에서 원격 저장소를 복제했을 때와 원격 저장소의 커밋 상황이 달라졌다. 따라서 회사 컴퓨터에서 작업하려면 먼저 원격 저장소에 새로 올라온 커밋을 가져와야 한다.

1. 앞에서 복제 과정을 거쳤기 때문에 git_office의 master 브랜치는 origin에 이미 연결되어 있다. 터미널 창에서 git_office 디렉토리로 이동한 후 git pull 명령을 입력하면 앞에서 원격 저장소에 새로 올라온 커밋을 가져온다.

   ```
   $ cd ~/git_office
   $ git pull
   ```

2. 저장소에 있는 f1.txt 파일을 수정해보자.

   ```
   $ vim f1.txt
   ```

3. 개인 컴퓨터에서 수정했던 'c'가 포함되어 있을 것이다. 회사 컴퓨터(git_office)에서는 영문자 d를 추가하고 저장한다.

4. 이제 'add d'라는 메시지와 함께 커밋을 만든 후 원격 저장소로 푸시한다.

   ```
   $ git commit -am 'add d'
   $ git push
   ```

5. 웹 브라우저에서 깃허브 저장소를 열고 [commits]를 확인하면 커밋 수가 1개 늘어나 있을 것이다.

6. 개인 컴퓨터에서 작업할 때는 git pull 명령으로 원격 저장소에 있는 최신 커밋을 가져와 작업을 시작한다. git log 명령으로 확인해 보면 회사 컴퓨터에서 푸시했던 'add d'라는 커밋이 개인 컴퓨터에도 들어와 있을 것이다.

   ```
   $ cd git_home
   $ git pull
   $ git log
   ```

   

### 05-2 원격 브랜치 정보 가져오기



#### 원격 master 브랜치

지역 저장소의 master 브랜치처럼 원격 저장소도 만들 때 기본으로 master 브랜치가 생성된다. 앞으로 git_home 저장소와 git_office 저장소로 원격 저장소를 복제한 상태로 실습을 계속하면서 확인해보겠다.

이제부터 원격 저장소에 있는 브랜치는 '원격 브랜치'로, 원격 저장소에 있는 master 브랜치는 '원격 master 브랜치'로 구별해서 부르겠다.

1. 깃허브에서 test-1 저장소로 접속한 후 [commits]를 눌러 보자. 'add d'라는 커밋이 마지막일 것이다. 여기에서 원격 저장소에 있는 HEAD는 원격 저장소의 master 브랜치를 가리킬 것이고, 원격 master 브랜치는 'add d'라는 최종 커밋을 가리킨다.

2. 터미널 창에서 git_home 디렉토리로 이동한 후 git log 명령으로 커밋 상태를 확인해 보자. 최종 커밋인 'add d' 앞에 (HEAD -> master, origin/master, origin/HEAD)라고 표시되어 있다.

   여기에서 HEAD -> master는 이 커밋의 지역 저장소의 최종 커밋이라는 뜻이고, origin/master는 원격 저장소의 최종 커밋이라는 뜻이다. 아직 git_home 디렉토리가 원격 저장소를 복제한 상태 그대로이기 때문에 지역 저장소와 원격 저장소 모두의 최종 커밋이 같다.

3. git_home 디렉토리에 새로운 커밋을 만들어 보겠다. vim을 사용해 f3.txt파일을 만든 후 간단히 'a'라고 입력하겠다. 파일 내용은 어떤 것을 입력해도 상관없다. 여기에서 새 파일을 만드는 것이 중요하다.

4. f3.txt를 스테이지에 올린 후 커밋을 만든다. 커밋 메시지는 'create f3.txt'라고 하자.

   ```
   $ git add f3.txt
   $ git commit -m 'create f3.txt'
   ```

5. git log --oneline 명령을 사용해 커밋 로그를 확인해 보자. (HEAD -> master )는 방금 커밋한 'create f3.txt'를 가리킨다. 지역 저장소의 최종 커밋이 'create f3.txt' 커밋이라는 뜻이다. 하지만 (origin/master, origin/HEAD)는 아직 'add d' 커밋을 가리키고 있다.

6. 이 상태에서 git status를 입력해 보세요. 현재 master 브랜치가 origin에 있는 원격 master 브랜치의 버전보다 하나 앞서 있는 것을 알 수 있다. 그리고 git push 명령으로 지역 저장소의 커밋을 원격 저장소로 올리라고 알려준다.

7. git push 명령을 사용해서 'create f3.txt'라는 커밋을 원격 저장소로 올린다. 그리고 나서 커밋 로그를 확인하자.

   ```
   $ git push
   $ git log --oneline
   ```

   

#### 원격 브랜치 정보 가져오기 - git fetch

fetch는 '**불러오다, 가져오다**'라는 뜻이다. 그래서 git fetch 명령은 원격 저장소의 정보를 가져오는 기능이 있다. 풀 명령이 원격 저장소의 커밋을 가져와서 무조건 지역 저장소와 합친다면, **fetch**명령은 원격 브랜치에 어떤 변화가 있는지 그 정보만 가져온다.

1. git_office 저장소로 이동해서 진행하겠다. 터미널 창에서 git_office 디렉토리로 이동한 후 git fetch 명령을 입력하자.
2. ls -al 명령을 사용해서 어떤 파일이 있는지 살펴보자. 분명히 원격 저장소에 있던 커밋을 가져왔는데 git_home에서 원격 저장소로 푸시해떤 f3.txt 파일이 보이지 않는다. 
3. git log 를 해보면 커밋 해시 오른쪽을 보면 (HEAD -> master)만 보이고 원격 저장소의 origin/master는 보이지 않는다. 원격 저장소의 최신 커밋 정보를 가져왔지만 아직 지역 저장소에 합치지 않아 원래 git_office에 있던 최신 커밋만 나타난다.

4. git status 명령으로 확인해 보면 현재 브랜치가 origin/master에 비해 1개의 커밋이 뒤쳐져 있다고 나온다. 즉, 원격 저장소의 최신 커밋 하나가 아직 지역 저장소에 반영되지 않았다는 뜻이다. git pull 명령을 사용하면 지역 저장소를 업데이트 할 수 있다고 알려준다.

5. 그렇다면 fetch로 가져온 최신 커밋 정보는 어디에 있을까? fetch로 가져온 원격 저장소 정보는 origin/master 브랜치가 아닌 FETCH_HEAD라는 브랜치로 가져온다. 이 브랜치로 가져온 정보는 지역 저장소에 바로 반영되지 않는다.

6. fetch해서 가져온 최신 커밋을 살펴보고 싶다면 FETCH_HEAD 브랜치로 체크아웃해서 확인한다.

   ```
   $ git checkout FETCH_HEAD
   ```

7.  FETCH_HEAD 브랜치에서 git log 명령을 사용해보자. 최신 커밋에 origin/master와 origin/HEAD가 표시되어 있다. 즉, 이 커밋이 fetch로 가져온 원격 브랜치의 최신 커밋이다. 이 내용을 살펴보고 원격 브랜치의 최신 커밋을 지역 저장소에 합칠지 말지를 결정하면 된다.

8. fetch 후에 최신 커밋을 현재 브랜치에 합치려면 **git pull** 명령을 사용해서 원격 저장소의 소스를 내려 받을수도 있고, **git merge** 명령으로 FETCH_HEAD에 있던 커밋을 병합할 수도 있다. 여기에서 git merge 명령으로 병합해 보자. master 브랜치로 이동한 뒤 병합하자.

   ```
   $ git checkout master
   $ git merge FETCH_HEAD
   ```

9. git log 명령을 사용해서 커밋 로그를 확인해 보자.



지금까지 살펴본 것처럼 git pull 명령은 git fetch 명령과 git merge FETCH_HEAD 명령 두개를 합친 것과 같은 기능을 한다. 즉, git fetch를 사용해 원격 브랜치를 가져온 다음 git merge 명령을 사용해 원격 브랜치와 현재 브랜치를 합쳐주는 것을 git pull 명령으로 한꺼번에 할 수 있다.



- fetch로 가져온 브랜치 한 번에 병합하기

  fetch한 뒤 병합할 때 원격 master 브랜치에 있는 커밋이라면 다음과 같이 병합

  ```
  $ git merge origin/master
  ```

  다른 브랜치에 있는 커밋이라면 다음과 같이 병합

  ```
  $ git merge orign/브랜치 이름
  ```

  fetch한 뒤 지역 저장소에 반영하지 않은 최신 커밋을 병합

  ```
  $ git merge FETCH_HEAD
  ```



### 05-3 협업의 기본 알아보기

















